const t=JSON.parse('{"key":"v-4bf749a7","path":"/posts/Algorithm/Advance/0x00/0x05.html","title":"排序","lang":"zh-CN","frontmatter":{"title":"排序","date":"2023-05-13T00:00:00.000Z","category":["算法"],"tag":["算法竞赛进阶指南"],"description":"程序设计中，排序算法通常有三类： 比较排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 O(nlog⁡n)O(n\\\\log n)O(nlogn)，因此也称为非线性时间比较类排序。 非比较排序：不通过比较来决定元素间的相对次序，它可以突破比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 混合排序：通过比较和非比较两种方法来进行排序，其时间复杂度介于上述两种之间，因此也称为线性对数比较类排序。 比较排序：通过比较元素之间的大小关系，逐一比较和交换元素的位置，使得排序后的元素满足总体有序的性质。常见的比较排序算法有冒泡排序、插入排序、选择排序、快速排序、归并排序、堆排序等。其中，快速排序、归并排序、堆排序都具有O(nlogn)的时间复杂度（最坏情况下）。 非比较排序：通过某种特殊的技术（如桶排序、计数排序、基数排序）来实现排序，不基于比较元素之间大小的关系。在一定的条件下，非比较排序算法的时间复杂度可以达到O(n)的线性复杂度。例如，计数排序和基数排序适用于排序值在一定范围内的整数序列，时间复杂度均为O(n+k)，其中k为正整数。 混合排序：结合两种或多种不同的排序算法，根据不同的数据属性和大小来选择更适合的排序算法。例如，C++标准库的sort函数就是一种经典的混合排序算法，它包括快速排序、插入排序、堆排序三种排序算法，会根据数据的大小和类型自适应地选择排序算法。 排序算法的选择取决于任务的特征和时间/空间的限制，不同的排序","head":[["meta",{"property":"og:url","content":"https://blog.izudia.top/posts/Algorithm/Advance/0x00/0x05.html"}],["meta",{"property":"og:site_name","content":"游者"}],["meta",{"property":"og:title","content":"排序"}],["meta",{"property":"og:description","content":"程序设计中，排序算法通常有三类： 比较排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 O(nlog⁡n)O(n\\\\log n)O(nlogn)，因此也称为非线性时间比较类排序。 非比较排序：不通过比较来决定元素间的相对次序，它可以突破比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 混合排序：通过比较和非比较两种方法来进行排序，其时间复杂度介于上述两种之间，因此也称为线性对数比较类排序。 比较排序：通过比较元素之间的大小关系，逐一比较和交换元素的位置，使得排序后的元素满足总体有序的性质。常见的比较排序算法有冒泡排序、插入排序、选择排序、快速排序、归并排序、堆排序等。其中，快速排序、归并排序、堆排序都具有O(nlogn)的时间复杂度（最坏情况下）。 非比较排序：通过某种特殊的技术（如桶排序、计数排序、基数排序）来实现排序，不基于比较元素之间大小的关系。在一定的条件下，非比较排序算法的时间复杂度可以达到O(n)的线性复杂度。例如，计数排序和基数排序适用于排序值在一定范围内的整数序列，时间复杂度均为O(n+k)，其中k为正整数。 混合排序：结合两种或多种不同的排序算法，根据不同的数据属性和大小来选择更适合的排序算法。例如，C++标准库的sort函数就是一种经典的混合排序算法，它包括快速排序、插入排序、堆排序三种排序算法，会根据数据的大小和类型自适应地选择排序算法。 排序算法的选择取决于任务的特征和时间/空间的限制，不同的排序"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-05-23T01:26:50.000Z"}],["meta",{"property":"article:author","content":"Izudia"}],["meta",{"property":"article:tag","content":"算法竞赛进阶指南"}],["meta",{"property":"article:published_time","content":"2023-05-13T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-05-23T01:26:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"排序\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-05-13T00:00:00.000Z\\",\\"dateModified\\":\\"2023-05-23T01:26:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Izudia\\",\\"url\\":\\"https://blog.izudia.top\\"}]}"]]},"headers":[],"git":{"createdTime":1684805210000,"updatedTime":1684805210000,"contributors":[{"name":"FoolAsphel","email":"foolasphel@outlook.com","commits":1}]},"readingTime":{"minutes":1.85,"words":555},"filePathRelative":"posts/Algorithm/Advance/0x00/0x05.md","localizedDate":"2023年5月13日","excerpt":"<p>程序设计中，排序算法通常有三类：</p>\\n<ul>\\n<li>比较排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 <span class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>O</mi><mo stretchy=\\"false\\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\\"false\\">)</mo></mrow><annotation encoding=\\"application/x-tex\\">O(n\\\\log n)</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.02778em;\\">O</span><span class=\\"mopen\\">(</span><span class=\\"mord mathnormal\\">n</span><span class=\\"mspace\\" style=\\"margin-right:0.1667em;\\"></span><span class=\\"mop\\">lo<span style=\\"margin-right:0.01389em;\\">g</span></span><span class=\\"mspace\\" style=\\"margin-right:0.1667em;\\"></span><span class=\\"mord mathnormal\\">n</span><span class=\\"mclose\\">)</span></span></span></span>，因此也称为非线性时间比较类排序。</li>\\n<li>非比较排序：不通过比较来决定元素间的相对次序，它可以突破比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</li>\\n<li>混合排序：通过比较和非比较两种方法来进行排序，其时间复杂度介于上述两种之间，因此也称为线性对数比较类排序。</li>\\n</ul>\\n<p>比较排序：通过比较元素之间的大小关系，逐一比较和交换元素的位置，使得排序后的元素满足总体有序的性质。常见的比较排序算法有冒泡排序、插入排序、选择排序、快速排序、归并排序、堆排序等。其中，快速排序、归并排序、堆排序都具有O(nlogn)的时间复杂度（最坏情况下）。</p>\\n<p>非比较排序：通过某种特殊的技术（如桶排序、计数排序、基数排序）来实现排序，不基于比较元素之间大小的关系。在一定的条件下，非比较排序算法的时间复杂度可以达到O(n)的线性复杂度。例如，计数排序和基数排序适用于排序值在一定范围内的整数序列，时间复杂度均为O(n+k)，其中k为正整数。</p>\\n<p>混合排序：结合两种或多种不同的排序算法，根据不同的数据属性和大小来选择更适合的排序算法。例如，C++标准库的sort函数就是一种经典的混合排序算法，它包括快速排序、插入排序、堆排序三种排序算法，会根据数据的大小和类型自适应地选择排序算法。</p>\\n<p>排序算法的选择取决于任务的特征和时间/空间的限制，不同的排序</p>\\n","autoDesc":true}');export{t as data};
