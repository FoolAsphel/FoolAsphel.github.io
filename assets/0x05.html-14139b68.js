import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as t,a as e,d as s,e as l}from"./app-b66a699a.js";const o={},m=s("p",null,"程序设计中，排序算法通常有三类：",-1),c=s("ul",null,[s("li",null,[l("比较排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mi",null,"log"),s("mo",null,"⁡"),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(n\\log n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mop"},[l("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),l("，因此也称为非线性时间比较类排序。")]),s("li",null,"非比较排序：不通过比较来决定元素间的相对次序，它可以突破比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。"),s("li",null,"混合排序：通过比较和非比较两种方法来进行排序，其时间复杂度介于上述两种之间，因此也称为线性对数比较类排序。")],-1),r=s("p",null,"比较排序：通过比较元素之间的大小关系，逐一比较和交换元素的位置，使得排序后的元素满足总体有序的性质。常见的比较排序算法有冒泡排序、插入排序、选择排序、快速排序、归并排序、堆排序等。其中，快速排序、归并排序、堆排序都具有O(nlogn)的时间复杂度（最坏情况下）。",-1),i=s("p",null,"非比较排序：通过某种特殊的技术（如桶排序、计数排序、基数排序）来实现排序，不基于比较元素之间大小的关系。在一定的条件下，非比较排序算法的时间复杂度可以达到O(n)的线性复杂度。例如，计数排序和基数排序适用于排序值在一定范围内的整数序列，时间复杂度均为O(n+k)，其中k为正整数。",-1),p=s("p",null,"混合排序：结合两种或多种不同的排序算法，根据不同的数据属性和大小来选择更适合的排序算法。例如，C++标准库的sort函数就是一种经典的混合排序算法，它包括快速排序、插入排序、堆排序三种排序算法，会根据数据的大小和类型自适应地选择排序算法。",-1),h=s("p",null,"排序算法的选择取决于任务的特征和时间/空间的限制，不同的排序",-1);function _(u,d){return a(),t("div",null,[m,c,r,i,p,h,e(" more ")])}const f=n(o,[["render",_],["__file","0x05.html.vue"]]);export{f as default};
